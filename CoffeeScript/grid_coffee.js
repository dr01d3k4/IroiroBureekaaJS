// Generated by CoffeeScript 1.6.3
(function(window) {
  var GRID_HEIGHT, GRID_WIDTH, Grid, START_HEIGHT;
  GRID_WIDTH = 14;
  GRID_HEIGHT = 20;
  START_HEIGHT = 6;
  Grid = (function() {
    var calculateLessStateChange;

    function Grid(width, height) {
      this.width = width;
      this.height = height;
      this.grid = [];
      this.markedForClear = [];
      this.lookedAt = [];
      this.isDirty = false;
      this.renderLessStateChange = [];
    }

    Grid.prototype.init = function() {
      var x, y, _i, _j, _ref, _ref1;
      for (x = _i = 0, _ref = this.width; _i < _ref; x = _i += 1) {
        this.grid[x] = [];
        this.markedForClear[x] = [];
        this.lookedAt[x] = [];
        for (y = _j = 0, _ref1 = this.height; _j < _ref1; y = _j += 1) {
          this.grid[x][y] = Colour.NONE;
          this.markedForClear[x][y] = false;
          this.lookedAt[x][y] = false;
        }
      }
      return null;
    };

    Grid.prototype.inBounds = function(x, y) {
      return x >= 0 && x < this.width && y >= 0 && y < this.height;
    };

    Grid.prototype.getColourAt = function(x, y) {
      if (this.inBounds(x, y)) {
        return this.grid[x][y];
      } else {
        return Color.NONE;
      }
    };

    Grid.prototype.setColourAt = function(x, y, colour) {
      if (this.inBounds(x, y)) {
        this.grid[x][y] = colour;
        return this.isDirty = true;
      }
    };

    Grid.prototype.isColourAt = function(x, y, colour) {
      return colour === this.getColourAt(x, y);
    };

    Grid.prototype.isEmptyAt = function(x, y) {
      return this.isColourAt(x, y, Colour.NONE);
    };

    Grid.prototype.isSolidAt = function(x, y) {
      return !isEmptyAt(x, y);
    };

    Grid.prototype.setEmptyAt = function(x, y) {
      return this.setColourAt(x, y, Colour.NONE);
    };

    Grid.prototype.isMarkedForClearAt = function(x, y) {
      if (this.inBounds(x, y)) {
        return this.markedForClear[x][y];
      } else {
        return false;
      }
    };

    Grid.prototype.setMarkedForClearAt = function(x, y, mark) {
      if (this.inBounds(x, y)) {
        return this.markedForClear[x][y] = mark;
      }
    };

    Grid.prototype.clearMarkedForClear = function() {
      var x, y, _i, _j, _ref, _ref1;
      for (x = _i = 0, _ref = this.width; _i < _ref; x = _i += 1) {
        for (y = _j = 0, _ref1 = this.height; _j < _ref1; y = _j += 1) {
          this.markedForClear[x][y] = false;
        }
      }
      return null;
    };

    Grid.prototype.hasBeenLookedAt = function(x, y) {
      if (this.inBounds(x, y)) {
        return this.lookedAt[x][y];
      } else {
        return true;
      }
    };

    Grid.prototype.setLookedAt = function(x, y, look) {
      if (this.inBounds(x, y)) {
        return this.lookedAt[x][y] = look;
      }
    };

    Grid.prototype.clearLookedAt = function() {
      var x, y, _i, _j, _ref, _ref1;
      for (x = _i = 0, _ref = this.width; _i < _ref; x = _i += 1) {
        for (y = _j = 0, _ref1 = this.height; _j < _ref1; y = _j += 1) {
          this.lookedAt[x][y] = false;
        }
      }
      return null;
    };

    calculateLessStateChange = function() {
      var i, x, y, _i, _j, _k, _ref, _ref1;
      if (!this.isDirty) {
        return;
      }
      this.renderLessStateChange = [];
      for (i = _i = 0; _i < colourIndexLength; i = _i += 1) {
        this.renderLessStateChange[i] = [];
      }
      for (x = _j = 0, _ref = this.width; _j < _ref; x = _j += 1) {
        for (y = _k = 0, _ref1 = this.height; _k < _ref1; y = _k += 1) {
          this.renderLessStateChange[colourToIndex[this.grid[x][y]]].push([x, y]);
        }
      }
      return this.isDirty = false;
    };

    Grid.prototype.findFloodClearCellsRecursive = function(x, y, colour, cells) {
      if (this.isColourAt(x, y, colour) && !this.hasBeenLookedAt(x, y)) {
        cells.push([x, y]);
        this.setLookedAt(x, y, true);
        this.findFloodClearCellsRecursive(x, y - 1, colour, cells);
        this.findFloodClearCellsRecursive(x + 1, y, colour, cells);
        this.findFloodClearCellsRecursive(x, y + 1, colour, cells);
        return this.findFloodClearCellsRecursive(x - 1, y, colour, cells);
      }
    };

    Grid.prototype.findFloodClearCells = function(x, y, colour) {
      var cells;
      cells = [];
      this.clearLookedAt();
      this.findFloodClearCellsRecursive(x, y, colour, cells);
      this.clearLookedAt();
      return cells;
    };

    return Grid;

  })();
  window.GRID_WIDTH = GRID_WIDTH;
  window.GRID_HEIGHT = GRID_HEIGHT;
  window.START_HEIGHT = START_HEIGHT;
  return window.Grid = Grid;
})(window);
